---
// This component contains the game UI structure
---

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
  <div class="score-container hidden" id="scoreBox">
    <div class="score" id="scoreDisplay">0</div>
    <div class="highscore">BEST: <span id="highScoreDisplay">0</span></div>
  </div>

  <div id="start-screen">
    <h1 class="title">PSYDUCK<br />STACK</h1>
    <p style="color: #E1BEE7; font-size: 1.2rem; margin-bottom: 25px; line-height: 1.5;">
      Tap to drop the Psyduck.<br />
      Land perfectly for bonus stability.<br />
      The headache grows with the tower.
    </p>
    <button class="btn" id="startBtn">PLAY</button>
  </div>

  <div id="game-over-screen" class="hidden">
    <h1 class="title">OH NO!</h1>
    <p style="color: white; font-size: 1.5rem; margin-bottom: 10px;">
      Height: <span id="finalScore">0</span> Ducks
    </p>
    <p style="color: #EF5350; font-size: 1.1rem; margin-bottom: 25px;" id="failMessage">
      The headache won.
    </p>
    <button class="btn" id="restartBtn">RETRY</button>
  </div>
</div>

<script>
  import type { GameState } from "@/scripts/game";
  import {
    CONFIG,
    Duck,
    Particle,
    initAudio,
    playSound,
  } from "@/scripts/game";

  const canvas = document.getElementById("gameCanvas") as HTMLCanvasElement;
  const ctx = canvas.getContext("2d", { alpha: false }) as CanvasRenderingContext2D;
  const scoreDisplay = document.getElementById("scoreDisplay") as HTMLElement;
  const highScoreDisplay = document.getElementById("highScoreDisplay") as HTMLElement;
  const scoreBox = document.getElementById("scoreBox") as HTMLElement;
  const startScreen = document.getElementById("start-screen") as HTMLElement;
  const gameOverScreen = document.getElementById("game-over-screen") as HTMLElement;
  const finalScoreEl = document.getElementById("finalScore") as HTMLElement;
  const failMessageEl = document.getElementById("failMessage") as HTMLElement;
  const uiLayer = document.getElementById("ui-layer") as HTMLElement;

  // Game State
  const state: GameState = {
    mode: "MENU",
    score: 0,
    highScore: Number.parseInt(localStorage.getItem("psyduck_highscore") || "0"),
    ducks: [],
    currentDuck: null,
    cameraY: 0,
    targetCameraY: 0,
    bgRotation: 0,
    width: window.innerWidth,
    height: window.innerHeight,
    baseY: 0,
    particles: [],
    gameSpeed: 1,
    stressLevel: 0,
  };

  // --- GAME LOGIC ---

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    state.width = canvas.width;
    state.height = canvas.height;
    state.baseY = state.height - 100;
  }
  window.addEventListener("resize", resize);

  function initGame() {
    resize();
    initAudio(); // Initialize audio context on first user interaction
    state.score = 0;
    state.ducks = [];
    state.particles = [];
    state.cameraY = 0;
    state.targetCameraY = 0;
    state.stressLevel = 0;

    highScoreDisplay.textContent = state.highScore.toString();

    // Base Duck
    const baseDuck = new Duck(state.width / 2, state.baseY, true, state.score);
    state.ducks.push(baseDuck);

    spawnNewDuck();

    state.mode = "PLAYING";
    scoreDisplay.textContent = state.score.toString();
    scoreBox.classList.remove("hidden");
    startScreen.classList.add("hidden");
    gameOverScreen.classList.add("hidden");
  }

  function spawnNewDuck() {
    const spawnY = state.baseY - (state.score + 1) * (CONFIG.duckHeight * 0.85) - 300;
    state.currentDuck = new Duck(state.width / 2, spawnY, false, state.score);
  }

  function triggerPerfect(x: number, y: number) {
    playSound("perfect");

    // UI Text
    const el = document.createElement("div");
    el.className = "perfect-text";
    el.textContent = "PERFECT!";
    el.style.left = `${state.width / 2}px`; // Centered on screen, not duck x (since duck is centered)
    el.style.top = "20%";
    uiLayer.appendChild(el);
    setTimeout(() => el.remove(), 1000);

    // Particles
    for (let i = 0; i < 20; i++) {
      state.particles.push(new Particle(x, y));
    }
  }

  function checkCollision() {
    const falling = state.currentDuck;
    if (!falling) return;

    const topDuck = state.ducks[state.ducks.length - 1];
    // Hitbox top
    const targetY = topDuck.y - CONFIG.duckHeight * 0.85;

    if (falling.y >= targetY) {
      const diff = falling.x - topDuck.x;
      const absDiff = Math.abs(diff);
      const maxDiff = CONFIG.duckWidth * CONFIG.hitTolerance;

      if (absDiff < maxDiff) {
        // LANDED
        falling.y = targetY; // Snap Y

        // Check PERFECT
        if (absDiff < CONFIG.perfectTolerance) {
          falling.x = topDuck.x; // Snap X
          triggerPerfect(falling.x, falling.y);
        }

        falling.isStatic = true;
        falling.isFalling = false;
        falling.squish();
        if (topDuck) topDuck.squish(); // Chain reaction squish? Just top one for now.

        state.ducks.push(falling);
        state.score++;
        scoreDisplay.textContent = state.score.toString();
        playSound("land");

        // Camera Logic
        // We want the new top duck to be at ~70% screen height
        const desiredScreenY = state.height * 0.7;
        // World Y of duck is falling.y (which is small/negative)
        // We render at y - cameraY
        // So: falling.y - cameraY = desiredScreenY
        // cameraY = falling.y - desiredScreenY
        state.targetCameraY = falling.y - desiredScreenY;

        spawnNewDuck();
      } else {
        // MISS -> Check if off screen
        if (falling.y > state.height + state.cameraY + 200) {
          gameOver();
        }
      }
    }
  }

  function gameOver() {
    state.mode = "GAMEOVER";
    playSound("fail");

    if (state.score > state.highScore) {
      state.highScore = state.score;
      localStorage.setItem("psyduck_highscore", state.score.toString());
    }

    finalScoreEl.textContent = state.score.toString();

    const puns = [
      "Too much headache!",
      "Psy-ai-ai...",
      "The tower has fallen.",
      "Confusion hit hard.",
    ];
    failMessageEl.textContent = puns[Math.floor(Math.random() * puns.length)];

    gameOverScreen.classList.remove("hidden");
  }

  function inputHandler(e: MouseEvent | TouchEvent | KeyboardEvent) {
    if (
      e.type === "click" ||
      e.type === "touchstart" ||
      (e instanceof KeyboardEvent && e.code === "Space")
    ) {
      // Prevent default only on canvas to allow UI interaction
      if (e.target === canvas) e.preventDefault();

      if (state.mode === "PLAYING" && state.currentDuck && !state.currentDuck.isFalling) {
        state.currentDuck.isFalling = true;
        playSound("drop");
      }
    }
  }

  // --- RENDER LOOP ---

  function drawBackground() {
    // Background color
    ctx.fillStyle = "#4A148C";
    ctx.fillRect(0, 0, state.width, state.height);

    ctx.save();
    ctx.translate(state.width / 2, state.height / 2);

    // Rotate background based on score/stress
    state.bgRotation += 0.002 + state.score * 0.0005;
    ctx.rotate(state.bgRotation);

    // Spiral
    const maxDim = Math.max(state.width, state.height) * 1.5;
    const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, maxDim);
    gradient.addColorStop(0, "#7B1FA2");
    gradient.addColorStop(0.5, "#4A148C");
    gradient.addColorStop(1, "#311B92");

    ctx.fillStyle = gradient;
    ctx.fillRect(-maxDim, -maxDim, maxDim * 2, maxDim * 2);

    // Trippy Lines
    ctx.strokeStyle = "rgba(255, 255, 255, 0.03)";
    ctx.lineWidth = 40;
    for (let i = 0; i < 12; i++) {
      ctx.beginPath();
      // Pulsing rings
      const pulse = Math.sin(Date.now() / 1000) * 20;
      const radius = Math.max(0, i * 120 + pulse); // Fix: Ensure radius is not negative
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }

  function loop() {
    // Update
    if (state.mode === "PLAYING") {
      if (state.currentDuck) state.currentDuck.update(state);
      for (const d of state.ducks) {
        d.update(state);
      }
      checkCollision();

      // Smooth Camera
      const diff = state.targetCameraY - state.cameraY;
      state.cameraY += diff * 0.05; // Smooth ease
    }

    // Particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.update();
      if (p.life <= 0) state.particles.splice(i, 1);
    }

    // Draw
    ctx.clearRect(0, 0, state.width, state.height);

    drawBackground();

    ctx.save();
    // Camera Transform: We shift the world up (negative Y) relative to cameraY
    // Since cameraY represents the top-left Y of the viewport in world space
    ctx.translate(0, -state.cameraY);

    // Platform
    ctx.fillStyle = "#FFC107";
    ctx.fillRect(0, state.baseY + CONFIG.duckHeight / 2, state.width, 1000);

    // Ducks
    for (const duck of state.ducks) {
      duck.draw(ctx, state.score);
    }
    if (state.currentDuck) state.currentDuck.draw(ctx, state.score);

    // Particles (World Space)
    for (const p of state.particles) {
      p.draw(ctx);
    }

    ctx.restore();

    requestAnimationFrame(loop);
  }

  // Inputs
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") inputHandler(e);
  });

  // Touch/Click on canvas
  canvas.addEventListener("mousedown", inputHandler);
  canvas.addEventListener("touchstart", inputHandler, { passive: false });

  // UI Buttons
  document.getElementById("startBtn")?.addEventListener("click", (e) => {
    e.stopPropagation();
    initGame();
  });

  document.getElementById("restartBtn")?.addEventListener("click", (e) => {
    e.stopPropagation();
    initGame();
  });

  // Initialize view
  resize();
  drawBackground(); // Draw once before loop starts
  loop(); // Start loop immediately so background animates
</script>
